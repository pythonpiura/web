<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python Piura (Python)</title><link>http://pythonpiura.org/</link><description></description><atom:link href="http://pythonpiura.org/categories/python.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Sun, 24 Jul 2016 17:44:06 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Reporte PDF en Django con Reportlab</title><link>http://pythonpiura.org/posts/2016/05/13/reporte-pdf-en-django-con-reportlab/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p style="text-align:justify;"&gt;Vamos a retomar nuestro proyecto tutorial, al que hemos tenido bastante olvidado estos últimos días y haremos un reporte en pdf utilizando la librería &lt;a href="http://www.reportlab.com/"&gt;reportlab&lt;/a&gt;, para ello la instalamos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
pip install reportlab&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Lo primero que haremos es poner el logo de django en la parte superior de nuestro reporte, por lo que debemos tener la imagen guardada en una ubicación fácil de obtener, por eso crearemos una carpeta llamada “media” en nuestro proyecto y dentro de esta, otra carpeta llamada imagenes, es aquí donde pondremos nuestro archivo logo_django.png:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/05/ubicacion_logo.jpg"&gt;&lt;img class="aligncenter size-full wp-image-280" src="http://pythonpiura.org/2016/05/ubicacion_logo.jpg" alt="ubicacion_logo" width="197" height="138"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Modificamos el archivo settings.py para poder establecer la ruta de la carpeta media:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
MEDIA_ROOT = os.path.join(BASE_DIR, ‘media’)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Creamos la clase ReportePersonasPDF en el archivo views.py, el código está explicado en los comentarios:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
#Importamos settings para poder tener a la mano la ruta de la carpeta media&lt;br&gt;
from django.conf import settings&lt;br&gt;
from io import BytesIO&lt;br&gt;
from reportlab.pdfgen import canvas&lt;br&gt;
from django.views.generic import View&lt;/p&gt;
&lt;p&gt;class ReportePersonasPDF(View):  &lt;/p&gt;
&lt;p&gt;    def cabecera(self,pdf):&lt;br&gt;
        #Utilizamos el archivo logo_django.png que está guardado en la carpeta media/imagenes&lt;br&gt;
        archivo_imagen = settings.MEDIA_ROOT+’/imagenes/logo_django.png’&lt;br&gt;
        #Definimos el tamaño de la imagen a cargar y las coordenadas correspondientes&lt;br&gt;
        pdf.drawImage(archivo_imagen, 40, 750, 120, 90,preserveAspectRatio=True)                &lt;/p&gt;
&lt;p&gt;    def get(self, request, *args, **kwargs):&lt;br&gt;
        #Indicamos el tipo de contenido a devolver, en este caso un pdf&lt;br&gt;
        response = HttpResponse(content_type=’application/pdf’)&lt;br&gt;
        #La clase io.BytesIO permite tratar un array de bytes como un fichero binario, se utiliza como almacenamiento temporal&lt;br&gt;
        buffer = BytesIO()&lt;br&gt;
        #Canvas nos permite hacer el reporte con coordenadas X y Y&lt;br&gt;
        pdf = canvas.Canvas(buffer)&lt;br&gt;
        #Llamo al método cabecera donde están definidos los datos que aparecen en la cabecera del reporte.&lt;br&gt;
        self.cabecera(pdf)&lt;br&gt;
        #Con show page hacemos un corte de página para pasar a la siguiente&lt;br&gt;
        pdf.showPage()&lt;br&gt;
        pdf.save()&lt;br&gt;
        pdf = buffer.getvalue()&lt;br&gt;
        buffer.close()&lt;br&gt;
        response.write(pdf)&lt;br&gt;
        return response&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Para poder acceder a esta clase debemos hacer la creación de la url correspondiente en el archivo urls.py:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
url(r’^reporte_personas_pdf/$’,login_required(ReportePersonasPDF.as_view()), name="reporte_personas_pdf"),&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Ahora vamos a utilizar la url desde el archivo personas.html:&lt;/p&gt;
&lt;p&gt;[sourcecode language="html"]&lt;br&gt;
&amp;lt;div class=’form-group’&amp;gt;&lt;br&gt;
	&amp;lt;div class="row"&amp;gt;&lt;br&gt;
		&amp;lt;div class="col-lg-9"&amp;gt;	&lt;/p&gt;
&lt;p&gt;		&amp;lt;/div&amp;gt;&lt;br&gt;
		&amp;lt;div class="col-lg-1"&amp;gt;&lt;br&gt;
			&amp;lt;a href="{% url ‘personas:reporte_personas_excel’ %}" class="btn btn-info btn-block"&amp;gt;&lt;br&gt;
				&amp;lt;span class="glyphicon glyphicon-list-alt"&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;
			&amp;lt;/a&amp;gt;&lt;br&gt;
		&amp;lt;/div&amp;gt;&lt;br&gt;
		{% if perms.personas.add_persona %}&lt;br&gt;
		&amp;lt;div class="col-lg-1"&amp;gt;&lt;br&gt;
			&amp;lt;a href="{% url ‘personas:crear_persona’ %}" class="btn btn-info btn-block"&amp;gt;&lt;br&gt;
				&amp;lt;span class="glyphicon glyphicon-plus"&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;
			&amp;lt;/a&amp;gt;&lt;br&gt;
		&amp;lt;/div&amp;gt;&lt;br&gt;
		{% endif %}&lt;br&gt;
		&amp;lt;div class="col-lg-1"&amp;gt;&lt;br&gt;
			&amp;lt;a href="{% url ‘personas:reporte_personas_pdf’ %}" class="btn btn-info btn-block"&amp;gt;&lt;br&gt;
				&amp;lt;span class="glyphicon glyphicon-file"&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;
			&amp;lt;/a&amp;gt;&lt;br&gt;
		&amp;lt;/div&amp;gt;&lt;br&gt;
	&amp;lt;/div&amp;gt;&lt;br&gt;
&amp;lt;/div&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Nos tiene que aparecer un ícono de un archivo:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/05/personas_pdf.jpg"&gt;&lt;img class="aligncenter size-large wp-image-281" src="https://pythonpiura.files.wordpress.com/2016/05/personas_pdf.jpg?w=604" alt="personas_pdf" width="604" height="119"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;El primer resultado será este:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/05/reporte_pdf1.jpg"&gt;&lt;img class="aligncenter size-large wp-image-282" src="https://pythonpiura.files.wordpress.com/2016/05/reporte_pdf1.jpg?w=604" alt="reporte_pdf1" width="604" height="220"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Vamos a ponerle un encabezado a nuestro reporte que diga “Python Piura” y debajo “Reporte de Personas”, para ello colocamos el siguiente código debajo de la última linea del método “cabecera”:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
        #Establecemos el tamaño de letra en 16 y el tipo de letra Helvetica&lt;br&gt;
        pdf.setFont("Helvetica", 16)&lt;br&gt;
        #Dibujamos una cadena en la ubicación X,Y especificada&lt;br&gt;
        pdf.drawString(230, 790, u"PYTHON PIURA")&lt;br&gt;
        pdf.setFont("Helvetica", 14)&lt;br&gt;
        pdf.drawString(200, 770, u"REPORTE DE PERSONAS")&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/05/reporte_pdf2.jpg"&gt;&lt;img class="aligncenter size-large wp-image-283" src="https://pythonpiura.files.wordpress.com/2016/05/reporte_pdf2.jpg?w=604" alt="reporte_pdf2" width="604" height="155"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Visualizaremos la tabla de personas, por lo que creamos el método tabla en la clase ReportePersonasPDF:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
def tabla(self,pdf,y):&lt;br&gt;
        #Creamos una tupla de encabezados para neustra tabla&lt;br&gt;
        encabezados = (‘DNI’, ‘Nombre’, ‘Apellido Paterno’, ‘Apellido Materno’)&lt;br&gt;
        #Creamos una lista de tuplas que van a contener a las personas&lt;br&gt;
        detalles = [(persona.dni, persona.nombre, persona.apellido_paterno, persona.apellido_materno) for persona in Persona.objects.all()]&lt;br&gt;
        #Establecemos el tamaño de cada una de las columnas de la tabla&lt;br&gt;
        detalle_orden = Table([encabezados] + detalles, colWidths=[2 * cm, 5 * cm, 5 * cm, 5 * cm])&lt;br&gt;
        #Aplicamos estilos a las celdas de la tabla&lt;br&gt;
        detalle_orden.setStyle(TableStyle(&lt;br&gt;
            [&lt;br&gt;
                #La primera fila(encabezados) va a estar centrada&lt;br&gt;
                ('ALIGN',(0,0),(3,0),'CENTER'),&lt;br&gt;
                #Los bordes de todas las celdas serán de color negro y con un grosor de 1&lt;br&gt;
                ('GRID', (0, 0), (-1, -1), 1, colors.black),&lt;br&gt;
                #El tamaño de las letras de cada una de las celdas será de 10&lt;br&gt;
                ('FONTSIZE', (0, 0), (-1, -1), 10),&lt;br&gt;
            ]&lt;br&gt;
        ))&lt;br&gt;
        #Establecemos el tamaño de la hoja que ocupará la tabla&lt;br&gt;
        detalle_orden.wrapOn(pdf, 800, 600)&lt;br&gt;
        #Definimos la coordenada donde se dibujará la tabla&lt;br&gt;
        detalle_orden.drawOn(pdf, 60,y)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Veamos como queda nuestro método get ahora con la nueva llamada al método tabla:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
def get(self, request, *args, **kwargs):&lt;br&gt;
        #Indicamos el tipo de contenido a devolver, en este caso un pdf&lt;br&gt;
        response = HttpResponse(content_type=’application/pdf’)&lt;br&gt;
        #La clase io.BytesIO permite tratar un array de bytes como un fichero binario, se utiliza como almacenamiento temporal&lt;br&gt;
        buffer = BytesIO()&lt;br&gt;
        #Canvas nos permite hacer el reporte con coordenadas X y Y&lt;br&gt;
        pdf = canvas.Canvas(buffer)&lt;br&gt;
        #Llamo al método cabecera donde están definidos los datos que aparecen en la cabecera del reporte.&lt;br&gt;
        self.cabecera(pdf)&lt;br&gt;
        y = 600&lt;br&gt;
        self.tabla(pdf, y)&lt;br&gt;
        #Con show page hacemos un corte de página para pasar a la siguiente&lt;br&gt;
        pdf.showPage()&lt;br&gt;
        pdf.save()&lt;br&gt;
        pdf = buffer.getvalue()&lt;br&gt;
        buffer.close()&lt;br&gt;
        response.write(pdf)&lt;br&gt;
        return response&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Y este será el resultado final:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/05/reporte_pdf3.jpg"&gt;&lt;img class="aligncenter size-large wp-image-285" src="https://pythonpiura.files.wordpress.com/2016/05/reporte_pdf3.jpg?w=604" alt="reporte_pdf3" width="604" height="379"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eso es todo por hoy.&lt;br&gt;
Saludos.&lt;/p&gt;
</description><category>Django</category><category>Python</category><category>reportlab</category><guid>http://pythonpiura.org/posts/2016/05/13/reporte-pdf-en-django-con-reportlab/</guid><pubDate>Sat, 14 May 2016 02:58:34 GMT</pubDate></item><item><title>Consulta DNI - RENIEC</title><link>http://pythonpiura.org/posts/2016/05/11/consulta-dni-reniec/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p style="text-align:justify;"&gt;En esta oportunidad vamos a hacer un ejemplo mas complejo, ya que el captcha así lo amerita, nuestra página objetivo es la siguiente:&lt;br&gt;
&lt;a href="https://cel.reniec.gob.pe/valreg/valreg.do"&gt;https://cel.reniec.gob.pe/valreg/valreg.do&lt;/a&gt;&lt;br&gt;
&lt;a href="http://pythonpiura.org/2016/05/reniec.jpg"&gt;&lt;img class="aligncenter size-full wp-image-274" src="http://pythonpiura.org/2016/05/reniec.jpg" alt="reniec" width="579" height="396"&gt;&lt;/a&gt;&lt;br&gt;
En esta página podemos ingresar el número de DNI y obtener el nombre completo del ciudadano. Como se ve en la imagen aquí nos enfrentamos a un captcha mas completo y a un teclado dinámico compuesto de botones, para romper este captcha tenemos que modificar la imagen para obtener el texto correcto, eliminando las lineas que atraviesan las letras y que tienen una tonalidad distinta de azul, el proceso no será 100% seguro pero funciona en la mayoría de los casos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
# -*- coding: utf-8 -*-&lt;br&gt;
from selenium import webdriver&lt;br&gt;
from selenium.webdriver.common.by import By&lt;br&gt;
from selenium.webdriver.support.wait import WebDriverWait&lt;br&gt;
from selenium.webdriver.support import expected_conditions as EC&lt;/p&gt;
&lt;p&gt;try:&lt;br&gt;
    import Image&lt;br&gt;
except ImportError:&lt;br&gt;
    from PIL import Image&lt;br&gt;
import pytesseract&lt;/p&gt;
&lt;p&gt;def ir_reniec_web(dni):&lt;br&gt;
    fp = webdriver.FirefoxProfile()&lt;br&gt;
    driver = webdriver.Firefox(fp)&lt;br&gt;
    #Definimos nuestra página objetivo&lt;br&gt;
    driver.get("https://cel.reniec.gob.pe/valreg/valreg.do")&lt;br&gt;
    try:&lt;br&gt;
        #Esperamos hasta que se cargue la imagen con el captcha&lt;br&gt;
        WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.ID, "imagcodigo")))&lt;br&gt;
    except:&lt;br&gt;
        print "Element is not present"&lt;br&gt;
    #Hacemos la captura de pantalla correspondiente&lt;br&gt;
    driver.save_screenshot("screenshot.png")&lt;br&gt;
    img=Image.open(‘screenshot.png’)&lt;br&gt;
    #Obtenemos el ancho y el largo de la imagen&lt;br&gt;
    ancho = img.size[0]&lt;br&gt;
    alto = img.size[1]&lt;br&gt;
    #Recortamos la parte del captcha teniendo en cuenta el ancho y el largo de la imagen&lt;br&gt;
    img_recortada = img.crop((int(ancho/4.26),int(alto/3.64),int(ancho/2.8),int(alto/3)))&lt;br&gt;
    #Guardamos el recorte&lt;br&gt;
    img_recortada.save("recorte.png")&lt;br&gt;
    #Recorremos cada uno de los dígitos del DNI&lt;br&gt;
    for num in dni:&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_0&lt;br&gt;
        boton_0 = driver.find_element_by_name("tecla_0")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_0&lt;br&gt;
        valor_0 = boton_0.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_1&lt;br&gt;
        boton_1 = driver.find_element_by_name("tecla_1")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_1&lt;br&gt;
        valor_1 = boton_1.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_2&lt;br&gt;
        boton_2 = driver.find_element_by_name("tecla_2")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_2&lt;br&gt;
        valor_2 = boton_2.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_3&lt;br&gt;
        boton_3 = driver.find_element_by_name("tecla_3")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_3&lt;br&gt;
        valor_3 = boton_3.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_4&lt;br&gt;
        boton_4 = driver.find_element_by_name("tecla_4")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_4&lt;br&gt;
        valor_4 = boton_4.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_5&lt;br&gt;
        boton_5 = driver.find_element_by_name("tecla_5")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_5&lt;br&gt;
        valor_5 = boton_5.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_6&lt;br&gt;
        boton_6 = driver.find_element_by_name("tecla_6")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_6&lt;br&gt;
        valor_6 = boton_6.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_7&lt;br&gt;
        boton_7 = driver.find_element_by_name("tecla_7")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_7&lt;br&gt;
        valor_7 = boton_7.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_8&lt;br&gt;
        boton_8 = driver.find_element_by_name("tecla_8")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_8&lt;br&gt;
        valor_8 = boton_8.get_attribute(‘value’)&lt;br&gt;
        #Buscamos el boton que tenga como nombre tecla_9&lt;br&gt;
        boton_9 = driver.find_element_by_name("tecla_9")&lt;br&gt;
        #Obtenemos el valor del botón con nombre tecla_9&lt;br&gt;
        valor_9 = boton_9.get_attribute(‘value’)&lt;br&gt;
        ”’Consultamos si el dígito del DNI es igual al valor del botón,&lt;br&gt;
        si es el caso entonces se da click en ese botón”’&lt;br&gt;
        if num==valor_0:&lt;br&gt;
            boton_0.click()&lt;br&gt;
        elif num==valor_1:&lt;br&gt;
            boton_1 = driver.find_element_by_name("tecla_1")&lt;br&gt;
            boton_1.click()&lt;br&gt;
        elif num==valor_2:&lt;br&gt;
            boton_2 = driver.find_element_by_name("tecla_2")&lt;br&gt;
            boton_2.click()&lt;br&gt;
        elif num==valor_3:&lt;br&gt;
            boton_3 = driver.find_element_by_name("tecla_3")&lt;br&gt;
            boton_3.click()&lt;br&gt;
        elif num==valor_4:&lt;br&gt;
            boton_4 = driver.find_element_by_name("tecla_4")&lt;br&gt;
            boton_4.click()&lt;br&gt;
        elif num==valor_5:&lt;br&gt;
            boton_5 = driver.find_element_by_name("tecla_5")&lt;br&gt;
            boton_5.click()&lt;br&gt;
        elif num==valor_6:&lt;br&gt;
            boton_6 = driver.find_element_by_name("tecla_6")&lt;br&gt;
            boton_6.click()&lt;br&gt;
        elif num==valor_7:&lt;br&gt;
            boton_7 = driver.find_element_by_name("tecla_7")&lt;br&gt;
            boton_7.click()&lt;br&gt;
        elif num==valor_8:&lt;br&gt;
            boton_8 = driver.find_element_by_name("tecla_8")&lt;br&gt;
            boton_8.click()&lt;br&gt;
        elif num==valor_9:&lt;br&gt;
            boton_9 = driver.find_element_by_name("tecla_9")&lt;br&gt;
            boton_9.click()&lt;br&gt;
    #Se llama al método romper_captcha para obtener el texto correspondiente&lt;br&gt;
    captcha = romper_captcha("recorte.png")&lt;br&gt;
    try:&lt;br&gt;
        #Obtenemos la caja de texto donde se escribe el texto del captcha&lt;br&gt;
        codigo = driver.find_element_by_name("imagen")&lt;br&gt;
        #Si el captcha está vacio o no se ha logrado romper se cierra el navegador y se termina la aplicación&lt;br&gt;
        if captcha==”:&lt;br&gt;
            driver.close()&lt;br&gt;
            return&lt;br&gt;
        #Escribimos el texto&lt;br&gt;
        codigo.send_keys(captcha)&lt;br&gt;
    except:&lt;br&gt;
        pass&lt;br&gt;
    try:&lt;br&gt;
        #Obtenemos el botón de consulta&lt;br&gt;
        boton_consultar=driver.find_element_by_name("bot_consultar")&lt;br&gt;
        #Damos click al botón de consulta&lt;br&gt;
        boton_consultar.click()&lt;br&gt;
    except:&lt;br&gt;
        print "Element is not present"&lt;br&gt;
    #Obtengo el resultado que aparece en el elemento llamado style2&lt;br&gt;
    resultado = driver.find_element_by_class_name("style2")&lt;br&gt;
    #Partimos el resultado para obtener el nombre&lt;br&gt;
    nombre = resultado.text.split(‘\n’)&lt;br&gt;
    driver.close()&lt;br&gt;
    return nombre[0]&lt;/p&gt;
&lt;p&gt;def romper_captcha(nombre_imagen):&lt;br&gt;
    #Abro la imagen&lt;br&gt;
    img = Image.open(nombre_imagen)&lt;br&gt;
    #Obtengo un arreglo de píxeles de la imagen&lt;br&gt;
    pixdata = img.load()&lt;br&gt;
    ”’Modifico los píxeles de la imagen de acuerdo al análisis de los colores de las letras&lt;br&gt;
    y las lineas que cruzan el texto, pintando de negro los píxeles del texto y de blanco las lineas”’&lt;br&gt;
    for y in xrange(img.size[1]):&lt;br&gt;
        for x in xrange(img.size[0]):&lt;br&gt;
            if pixdata[x, y][2] &amp;lt; 146: pixdata[x, y] = (255, 255, 255) for y in xrange(img.size[1]): for x in xrange(img.size[0]): if pixdata[x, y][1] &amp;gt; 64:&lt;br&gt;
                pixdata[x, y] = (255, 255, 255)&lt;br&gt;
            else:&lt;br&gt;
                pixdata[x, y] = (0,0,0)&lt;br&gt;
    #Guardo la imagen modificada&lt;br&gt;
    img.save("modificado.jpg")&lt;br&gt;
    #Abro la imagen modificado&lt;br&gt;
    image = Image.open("modificado.jpg")&lt;br&gt;
    #Obtenemos el texto de la imagen&lt;br&gt;
    frase = pytesseract.image_to_string(image)&lt;br&gt;
    #Retornamos el texto eliminado los espacios en blanco entre las palabras y convirtiendolas en mayúsculas&lt;br&gt;
    return frase.replace(‘ ‘,”).upper()&lt;/p&gt;
&lt;p&gt;def main():&lt;br&gt;
    dni = ’123456789′&lt;br&gt;
    print ir_reniec_web(dni)&lt;/p&gt;
&lt;p&gt;main()&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Espero que les sea útil.&lt;br&gt;
Saludos.&lt;/p&gt;
</description><category>pillow</category><category>pytesseract</category><category>Python</category><category>Selenium</category><guid>http://pythonpiura.org/posts/2016/05/11/consulta-dni-reniec/</guid><pubDate>Thu, 12 May 2016 02:37:08 GMT</pubDate></item><item><title>Web Scrapping con Python y Selenium</title><link>http://pythonpiura.org/posts/2016/05/07/web-scrapping-con-python-y-selenium/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p style="text-align:justify;"&gt;El día de hoy tuvimos el agrado de ser invitados por el &lt;a href="https://cideuel.wordpress.com/"&gt;Círculo UEL&lt;/a&gt; a dar una charla en el marco del FLISOL 2016 en la Universidad Los Ángeles de Chimbote Sede Piura y el tema fue Web Scrapping con Python y Selenium, hicimos algunos ejemplos muy interesantes y nos encantó la acogida del público y el interés suscitado, vamos a compartir los artículos que usamos:&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;&lt;a href="https://pythonpiura.wordpress.com/2014/09/18/selenium-con-python/"&gt;Selenium con Python&lt;/a&gt;&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;&lt;a href="https://pythonpiura.wordpress.com/2016/01/26/romper-captchas-con-pytesseract-y-selenium/"&gt;Romper Captchas con Pytesseract y Selenium&lt;/a&gt;&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Las diapositivas:&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;&lt;a href="http://pythonpiura.org/2016/05/charlapythonflisol2016.pdf"&gt;Descargar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;El script que fue la estrella de la mañana:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
# -*- coding: utf-8 -*-&lt;br&gt;
from selenium import webdriver&lt;br&gt;
from selenium.webdriver.common.by import By&lt;br&gt;
from selenium.webdriver.support.wait import WebDriverWait&lt;br&gt;
from selenium.webdriver.support import expected_conditions as EC&lt;br&gt;
import os&lt;/p&gt;
&lt;p&gt;try:&lt;br&gt;
    import Image&lt;br&gt;
except ImportError:&lt;br&gt;
    from PIL import Image&lt;br&gt;
import pytesseract&lt;/p&gt;
&lt;p&gt;def decodifica_campo(campo):&lt;br&gt;
	return u"%s" % campo&lt;/p&gt;
&lt;p&gt;def ir_sunat_web(ruta):&lt;br&gt;
	fp = webdriver.FirefoxProfile()&lt;br&gt;
	fp.set_preference("browser.download.manager.showWhenStarting",False)&lt;br&gt;
	fp.set_preference("browser.download.manager.closeWhenDone", True);&lt;br&gt;
	fp.set_preference("browser.download.manager.showAlertOnComplete", False);&lt;br&gt;
	fp.set_preference("browser.helperApps.neverAsk.saveToDisk", "application/zip");&lt;br&gt;
	driver = webdriver.Firefox(fp)&lt;br&gt;
	driver.get("http://www.sunat.gob.pe/cl-ti-itmrconsmulruc/jrmS00Alias")&lt;br&gt;
	try:&lt;br&gt;
		WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.NAME, "imagen")))&lt;br&gt;
	except:&lt;br&gt;
		print "No carga imagen"&lt;br&gt;
	driver.save_screenshot("screenshot.png")&lt;br&gt;
	img=Image.open(‘screenshot.png’)&lt;br&gt;
	img_recortada = img.crop((700,309,800,361))&lt;br&gt;
	img_recortada.save("recorte.png")&lt;br&gt;
        try:&lt;br&gt;
            captcha = pytesseract.image_to_string(img_recortada)&lt;br&gt;
            codigo = driver.find_element_by_name("codigoA")&lt;br&gt;
            codigo.send_keys(captcha)&lt;br&gt;
        except:&lt;br&gt;
            pass&lt;br&gt;
	archivo = driver.find_element_by_name("archivo")&lt;br&gt;
	archivo.send_keys(ruta)&lt;br&gt;
	form = driver.find_element_by_name("frmConsMulRucArchivo")&lt;br&gt;
	botones=form.find_elements_by_class_name("form-button")&lt;br&gt;
	botones[1].click()&lt;br&gt;
	try:&lt;br&gt;
		WebDriverWait(driver, 5).until(EC.presence_of_all_elements_located((By.CLASS_NAME, "form-table")))&lt;br&gt;
		enlace=driver.find_element(By.TAG_NAME,"a")&lt;br&gt;
		enlace.click()&lt;br&gt;
	except:&lt;br&gt;
		print "Element is not present"&lt;br&gt;
	driver.close()&lt;/p&gt;
&lt;p&gt;def main():&lt;br&gt;
	ruta = "/home/usuario/carpeta"&lt;br&gt;
	ruta_archivo=os.path.join(ruta,"rucs.zip")&lt;br&gt;
	ir_sunat_web(ruta_archivo)&lt;/p&gt;
&lt;p&gt;main()&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Así como también un vídeo de su funcionamiento.&lt;/p&gt;
&lt;p&gt;http://www.youtube.com/watch?v=mUaVFYTlibM&lt;/p&gt;
&lt;p&gt;Saludos y muchas gracias.&lt;/p&gt;
</description><category>pillow</category><category>pytesseract</category><category>Python</category><category>Selenium</category><guid>http://pythonpiura.org/posts/2016/05/07/web-scrapping-con-python-y-selenium/</guid><pubDate>Sun, 08 May 2016 01:58:06 GMT</pubDate></item><item><title>Deployando Proyectos Django en Heroku</title><link>http://pythonpiura.org/posts/2016/04/17/deployando-proyectos-django-en-heroku/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p style="text-align:justify;"&gt;&lt;a href="https://www.heroku.com/"&gt;Heroku&lt;/a&gt; es una plataforma que brinda servicios en la nube y soporta varios lenguajes de programación, funciona muy bien con Python y Django y en esta ocasión haremos un pequeño tutorial basado en el tutorial oficial, que se puede encontrar en la página del proyecto.&lt;br&gt;
Para empezar  a trabajar debemos tener una cuenta en Heroku, hay planes de varios tipos, nosotros escogeremos el plan Free. Antes de empezar nos vamos a cerciorar de tener instaladas algunas cosas básicas, que ya hemos visto antes pero que siempre es bueno recordar:&lt;/p&gt;
&lt;ul style="text-align:justify;"&gt;
&lt;li&gt;Pip.&lt;/li&gt;
&lt;li&gt;Virtualenv&lt;/li&gt;
&lt;li&gt;Git.&lt;/li&gt;
&lt;li&gt;Y en nuestro caso la base de datos PostgreSQL.&lt;/li&gt;
&lt;/ul&gt;
&lt;p style="text-align:justify;"&gt;El primer paso es instalar Heroku Toolbelt, esta aplicación provee acceso a la interfaz de linea de comandos(CLI) de Heroku, que es usada para administrar y escalar nuestras aplicaciones y sus añadidos, para tenerlo instalado debemos poner el siguiente comando en nuestra terminal:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;El script nos pedira permisos de superusuario para continuar, se los damos y esperamos que la instalación se efectue.&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Una vez que hemos terminado de instalar debemos loguearnos utilizando el usuario y password que hemos registrado en la página de Heroku de la siguiente manera:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku login&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Si es la primera vez que lanzamos la aplicación se demorará un poquito instalando y configurando todo lo necesario, despues nos pedirá usuario y password, si ingresamos las credenciales correctamente nos saldrá un mensaje como este:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
Logged in as miguel.amaya99@gmail.com&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Una vez que hemos hecho esto el manual oficial de Heroku nos indica que debemos clonar una aplicación de prueba para deployar, nosotros ya tenemos una aplicación desarrollada por lo que debemos hacer algunos cambios a esta para poder subirla sin ningún problema.&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Primero debemos agregar dos archivos en la raiz del proyecto:&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;El archivo procfile que debe tener el siguiente contenido:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
web: gunicorn volpox.wsgi –log-file -&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;En la parte donde dice “volpox.wsgi” se debe reemplazar por el nombre de su proyecto.&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;El archivo requirements.txt debe tener todos las aplicaciones que nuestro proyecto necesita para funcionar correctamente, esto se puede averiguar facilmente ejecutando el comando pip freeze y guardando su contenido en el archivo, en nuestro caso el contenido del archivo es el siguiente:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
dj-database-url==0.4.0&lt;br&gt;
Django==1.9.2&lt;br&gt;
gunicorn==19.4.5&lt;br&gt;
psycopg2==2.6.1&lt;br&gt;
whitenoise==2.0.6&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Debemos tener en cuenta que este es el contenido básico para garantizar el correcto funcionamiento de nuestra aplicación en Heroku, hemos adicionado el paquete psycopg2 para poder trabajar con postgresql, si su proyecto usa algún paquete de software adicional, póngalo en este archivo.&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Ahora debemos modificar el archivo settings.py agregando las siguientes lineas:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
#Al inicio&lt;/p&gt;
&lt;p&gt;import dj_database_url&lt;/p&gt;
&lt;p&gt;PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;En la parte donde está:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
ALLOWED_HOSTS = []&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Lo cambiamos por:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
ALLOWED_HOSTS = ['*']&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;En la parte final agregamos esto:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
db_from_env = dj_database_url.config(conn_max_age=500)&lt;br&gt;
DATABASES['default'].update(db_from_env)&lt;/p&gt;
&lt;p&gt;# Honor the ‘X-Forwarded-Proto’ header for request.is_secure()&lt;br&gt;
SECURE_PROXY_SSL_HEADER = (‘HTTP_X_FORWARDED_PROTO’, ‘https’)&lt;br&gt;
# Static files (CSS, JavaScript, Images)&lt;br&gt;
# https://docs.djangoproject.com/en/1.8/howto/static-files/&lt;/p&gt;
&lt;p&gt;STATIC_ROOT = os.path.join(PROJECT_ROOT, ‘staticfiles’)&lt;/p&gt;
&lt;p&gt;STATIC_URL = ‘/static/’&lt;/p&gt;
&lt;p&gt;# Extra places for collectstatic to find static files.&lt;br&gt;
STATICFILES_DIRS = (&lt;br&gt;
os.path.join(BASE_DIR, ‘static’),&lt;br&gt;
)&lt;br&gt;
STATICFILES_STORAGE = ‘whitenoise.django.GzipManifestStaticFilesStorage’&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Ahora debemos cambiar el contenido del archivo wsgi.py&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
import os&lt;br&gt;
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "volpox.settings")&lt;/p&gt;
&lt;p&gt;from django.core.wsgi import get_wsgi_application&lt;br&gt;
from whitenoise.django import DjangoWhiteNoise&lt;/p&gt;
&lt;p&gt;application = get_wsgi_application()&lt;br&gt;
application = DjangoWhiteNoise(application)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;También debemos crear un archivo .gitignore, que es usado por git para no trabajar con las extensiones de archivos mencionados aquí en nuestro caso serán las siguientes:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
venv&lt;br&gt;
*.pyc&lt;br&gt;
staticfiles&lt;br&gt;
.env&lt;br&gt;
db.sqlite3&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Ahora debemos crear un repositorio git con el siguiente comando:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
git init&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Añadimos los archivos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
git add *&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Y hacemos nuestro primer commit:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
git commit -m "Deployando proyecto"&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Creamos nuestro proyecto en Heroku:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku create volpox&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Ahora si procedamos a subir nuestro proyecto a Heroku:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
git push heroku master&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Si tuviesemos algún error, revisar los archivos de la carpeta static, generalmente la mayoría de errores se presentan por rutas no encontradas o cosas así.&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Si todo ha salido correctamente vamos a proceder a asegurarnos de que al menos una instancia de la aplicación se está ejecutando:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku ps:scale web=1&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Ahora abrimos el proyecto con el navegador por defecto:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku open&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Listo, ya tenemos nuestra aplicación funcionando correctamente, ahora falta configurar la base de datos, para ello vamos a utilizar el siguiente comando:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku addons&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Con esto añadimos una base de datos PostgreSQL en el plan Free de nuestra cuenta.&lt;br&gt;
Los siguiente comandos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku config&lt;br&gt;
heroku pg&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Nos permiten ver la configuración de nuestra base de datos.&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Procedemos a crear nuestras tablas en la base de datos creada, usando el comando migrate de la siguiente manera:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku run python manage.py migrate&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Si es necesario procedemos a crear nuestro superusuario:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
heroku run python manage.py createsuperuser&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Listo ya tenemos nuestra aplicación desplegada. Hasta la próxima.&lt;/p&gt;
</description><category>Django</category><category>Python</category><guid>http://pythonpiura.org/posts/2016/04/17/deployando-proyectos-django-en-heroku/</guid><pubDate>Sun, 17 Apr 2016 21:44:49 GMT</pubDate></item><item><title>Servir Aplicaciones Django con Apache y mod_wsgi en Centos 7</title><link>http://pythonpiura.org/posts/2016/04/14/servir-aplicaciones-django-con-apache-y-mod_wsgi-en-centos-7/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p style="text-align:justify;"&gt;Para instalar un servidor de producción Django en Centos 7 usaremos Apache y mod_wsgi, mod_wsgi es un módulo de Apache, que permite servir aplicaciones hechas en Python, que tengan soporte para la interfaz WSGI.&lt;br&gt;
Los requisitos para esto son tener un servidor Centos 7 correctamente instalado y configurado y los permisos de root para poder hacer las instalaciones correspondientes. Para comenzar el proceso, vamos a descargar e instalar todos los elementos que necesitamos de los repositorios de la distribución. Esto incluirá el servidor web Apache, el módulo mod_wsgi utilizado para interactuar con nuestra aplicación Django, y pip. Para obtener pip, tendremos que habilitar el repositorio EPEL(paquetes para Linux Empresarial):&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
yum install epel-release&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Con EPEL habilitado nosotros podemos instalar los componentes tipeando:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
yum install python-pip httpd mod_wsgi&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Ahora que ya tenemos instalados los paquetes necesarios, debemos crear un entorno virtual para ellos instalaremos virtualenv usando pip:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
pip install virtualenv&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Ahora procedemos a crear nuestro entorno virtual:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
virtualenv vproduccion&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Y lo activamos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
source vproduccion/bin/activate&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Cuando activamos el entorno virtual nuestro prompt debe cambiar y aparecer entre paréntesis el nombre del entorno virtual activado.&lt;br&gt;
Una vez que esto ha sucedido debemos instalar Django:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
pip install django&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Cuando ya tengamos listo esto, subimos o creamos nuestro proyecto Django utilizando los comandos clásicos que ya hemos utilizado antes, ahora nos toca configurar Apache.&lt;br&gt;
Una vez que comprobamos que el proyecto Django está funcionando, podemos configurar Apache como un front-end. Las conexiones de cliente que recibe serán traducidos al formato WSGI que la aplicación Django espera utilizando el módulo mod_wsgi. Esto debería haber sido activado automáticamente después de la instalación anterior. Para configurar lo anterior, tendremos que crear un nuevo archivo de configuración en el directorio /etc/httpd/conf.d. Vamos a llamar a este archivo django.conf:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
nano /etc/httpd/conf.d/django.conf&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Y dentro de él escribiremos lo siguiente:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
#En mi caso la ruta es /home/jamaya y mi proyecto se llama siad&lt;br&gt;
#Configuración para mostrar correctamente losa archivos estáticos&lt;br&gt;
Alias /static /home/jamaya/siad/static&lt;br&gt;
&amp;lt;Directory /home/jamaya/siad/static&amp;gt;&lt;br&gt;
        Require all granted&lt;br&gt;
&amp;lt;/Directory&amp;gt;&lt;br&gt;
#Configuración para acceder correctamente al wsgi.py&lt;br&gt;
&amp;lt;Directory /home/jamaya/siad/siad/&amp;gt;&lt;br&gt;
&amp;lt;Files wsgi.py&amp;gt;&lt;br&gt;
        Require all granted&lt;br&gt;
&amp;lt;/Files&amp;gt;&lt;br&gt;
&amp;lt;/Directory&amp;gt;&lt;/p&gt;
&lt;p&gt;WSGIDaemonProcess siad python-path=/home/jamaya/siad:/home/jamaya/vproduccion/lib/python2.7/site-packages&lt;br&gt;
WSGIProcessGroup siad&lt;br&gt;
WSGIScriptAlias /siad /home/jamaya/siad/siad/wsgi.py&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;A continuación, tenemos que arreglar los permisos para que el servicio de Apache puede acceder a nuestros archivos. Por defecto CentOS bloquea el directorio personal de cada usuario de manera muy restrictiva. Para evitar esto, añadiremos el usuario apache al grupo de nuestro propio usuario. Esto nos permitirá abrir los permisos sólo lo suficiente para que pueda llegar a los archivos correspondientes.&lt;br&gt;
Añadimos el usuario apache a nuestro grupo, reemplazamos la palabra jamaya con nuestro usuario:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
usermod -a -G jamaya apache&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Damos permisos al grupo en la carpeta personal, esto permitirá al proceso apache acceder a los archivos.&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
chmod 710 /home/jamaya&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Ya podemos iniciar el servicio de apache:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
systemctl start httpd&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vamos a probar si la carga del proyecto funciona, vamos a otra computadora de la red y colocamos la direccion ip de nuestro servidor y la aplicación:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
http://172.20.30.129/siad&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si hubiese algún problema lo mas rápido y sencillo es deshabilitar SELINUX, esto lo hacemos editando el archivo:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
/etc/selinux/config&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Y cambiando la siguiente linea:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
SELINUX=disabled&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si todo funciona correctamente habilitamos el servicio apache para que se inicie automaticamente:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
systemctl enable httpd&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Recuerden tener siempre su archivo requerimientos.txt o requirements.txt para instalar todas las dependendencias que hacen que nuestro proyecto funcione con éxito. Este archivo se obtiene en nuestro entorno de desarrollo escribiendo el siguiente comando:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
pip freeze &amp;gt; requirements.txt&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Y para instalarlas en nuestro entorno de producción usamos el mismo comando con algunas variantes:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
pip install -r requirements.txt&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;En el caso nuestro teniamos un par de dependencias un poco complicadas de instalar en Centos: Pillow y psycopg2, por lo que tuvimos algunos errores, para solucionarlos debemos instalar algunas librerias, en centos en el caso de psycopg2 tenemos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
yum install gcc&lt;br&gt;
yum install postgresql-devel python-devel&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Y en el caso de Pillow:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
yum install libjpeg-devel zlib-devel&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Y listo eso es todo, ya tenemos nuestro servidor de producción.&lt;/p&gt;
&lt;p&gt;Saludos.&lt;/p&gt;
</description><category>Centos</category><category>Django</category><category>Python</category><guid>http://pythonpiura.org/posts/2016/04/14/servir-aplicaciones-django-con-apache-y-mod_wsgi-en-centos-7/</guid><pubDate>Fri, 15 Apr 2016 03:34:33 GMT</pubDate></item><item><title>Romper Captchas con Pytesseract y Selenium</title><link>http://pythonpiura.org/posts/2016/01/26/romper-captchas-con-pytesseract-y-selenium/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p&gt;En muchas de las páginas que consultamos tenemos una imagen que contiene un pequeño texto que generalmente es de 4 o de 6 letras, esta imagen es conocida como captcha y sirve para evitar la consulta masiva de datos y el uso de boots para hacer consultas, el problema radica en que podemos convertir esta imagen en texto y buscar la forma de ingresar estos datos de manera automática sin intervención humana. Para hacer la conversión de la imagen en texto tenemos la librería pytesseract que hace uso del programa tesseract-ocr y para el ingreso automático de datos y el acceso a la página objetivo contamos con la ayuda de nuestro viejo conocido selenium, cabe destacar que este procedimiento funciona siempre y cuando la imagen del captcha no sea tan complejo y contenga solamente texto.&lt;br&gt;
Hemos creado un script de manera general sin tener una página objetivo en específico, pero para aplicarlo se debe conocer bien la página a testear tal como hemos explicado en posts anteriores, analizando sus elementos y la ubicación del captcha.&lt;br&gt;
Antes de empezar debemos tener instalado el programa tesseract-ocr ya que no podremos hacer nada sin este, lo podemos descargar de la siguiente &lt;a href="http://en.osdn.jp/projects/sfnet_tesseract-ocr-alt/downloads/tesseract-ocr-setup-3.02.02.exe/"&gt;ubicación&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Posteriormente procedemos a instalar las librerias pytesseract y pillow(para el manejo y tratamiento de imágenes)&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;pip install pillow&lt;br&gt;
pip install pytesseract&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Y finalmente hacemos nuestro script el cual está debidamente documentado para que lo puedan adaptar y modificar a su gusto.&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
# -*- coding: utf-8 -*-&lt;br&gt;
from selenium import webdriver&lt;br&gt;
from selenium.webdriver.common.by import By&lt;br&gt;
from selenium.webdriver.support.wait import WebDriverWait&lt;br&gt;
from selenium.webdriver.support import expected_conditions as EC&lt;/p&gt;
&lt;p&gt;try:&lt;br&gt;
    import Image&lt;br&gt;
except ImportError:&lt;br&gt;
    from PIL import Image&lt;br&gt;
import pytesseract&lt;/p&gt;
&lt;p&gt;def ir_pagina_web(cadena,direccion_web):&lt;br&gt;
    driver = webdriver.Firefox()&lt;br&gt;
    #Vamos a la dirección web de la página objetivo&lt;br&gt;
    driver.get(direccion_web)&lt;br&gt;
    try:&lt;br&gt;
        #Esperamos que se cargue correctamente la caja de texto de búsqueda&lt;br&gt;
        WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.ID, "txtBusqueda")))&lt;br&gt;
    except:&lt;br&gt;
        print "El elemento no está presente"&lt;br&gt;
    #Obtenemos la caja de texto de búsqueda&lt;br&gt;
    placa = driver.find_element_by_id("txtBusqueda")&lt;br&gt;
    #Enviamos la cadena a buscar en la caja de texto&lt;br&gt;
    placa.send_keys(cadena)&lt;br&gt;
    #Hacemos una captura de pantalla de la página objetivo&lt;br&gt;
    driver.save_screenshot("screenshot.jpg")&lt;br&gt;
    #Abrimos la captura hecha&lt;br&gt;
    img=Image.open(‘screenshot.jpg’)&lt;br&gt;
    #Recortamos la captura de acuerdo a la ubicación del captcha.&lt;br&gt;
    #El primer argumento es la posición "x" inicial, el segundo la posición "y" inicial.&lt;br&gt;
    #El tercer argumento es la posición "x" final y el cuarto la posición "y" final.&lt;br&gt;
    img_recortada = img.crop((380,300,550,340))&lt;br&gt;
    #Guardamos el área seleccionada con el nombre de "recorte.jpg"&lt;br&gt;
    img_recortada.save("recorte.jpg")&lt;br&gt;
    try:&lt;br&gt;
        #Convertimos la imagen a cadena de texto usando la libreria pytesseract&lt;br&gt;
        captcha = pytesseract.image_to_string(img_recortada)&lt;br&gt;
        #Obtenemos la caja de texto donde se ingresa el contenido del captcha&lt;br&gt;
        codigo = driver.find_element_by_id("txtCaptcha")&lt;br&gt;
        #Enviamos el captcha obtenido&lt;br&gt;
        codigo.send_keys(captcha)&lt;br&gt;
    except:&lt;br&gt;
        print "Error al convertir imagen en texto"&lt;br&gt;
    #Obtenemos el botón buscar&lt;br&gt;
    boton=driver.find_element_by_id("btn_buscar")&lt;br&gt;
    #Hacemos click en el botón&lt;br&gt;
    boton.click()&lt;br&gt;
    driver.close()&lt;/p&gt;
&lt;p&gt;def main():&lt;br&gt;
    ir_pagina_web("cadena","direccion_web")&lt;/p&gt;
&lt;p&gt;main()&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Por cierto hemos realizado esta prueba en Windows, nos queda la tarea pendiente de hacerlo en GNU/Linux.&lt;/p&gt;
</description><category>Python</category><category>Selenium</category><guid>http://pythonpiura.org/posts/2016/01/26/romper-captchas-con-pytesseract-y-selenium/</guid><pubDate>Tue, 26 Jan 2016 19:17:00 GMT</pubDate></item><item><title>Web Scraping con Selenium</title><link>http://pythonpiura.org/posts/2016/01/25/web-scraping-con-selenium/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p&gt;En entradas anteriores comentabamos sobre el uso de Selenium para hacer test, en esta oportunidad lo utilizaremos para extraer datos de una web en particular, ahora manos a la obra.&lt;br&gt;
Para hacer la extracción de datos primero necesitamos conocer bien la página web objetivo, en este caso es una página de consulta de datos de teléfonos de personas y empresas llamada “Páginas Blancas” su URL es la siguiente:&lt;br&gt;
http://www.paginasblancas.pe/&lt;/p&gt;
&lt;p&gt;Y también debemos conocer el modo de funcionamiento de la página en cuestión, en este caso se debe ingresar la cadena a buscar en una caja de texto y presionar un botón que dice “Buscar” para enviar la consulta, si hay datos coincidentes con el texto ingresado, la página nos mostrará una lista de resultados que contienen la razón social o nombre, la dirección y el teléfono:&lt;/p&gt;
&lt;p&gt;Búsqueda&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/01/busqueda.png" rel="attachment wp-att-89"&gt;&lt;img class="alignnone size-medium wp-image-89" src="https://pythonpiura.files.wordpress.com/2016/01/busqueda.png?w=300" alt="busqueda" width="300" height="102"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Resultados&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/01/resultados.png" rel="attachment wp-att-90"&gt;&lt;img class="alignnone size-medium wp-image-90" src="https://pythonpiura.files.wordpress.com/2016/01/resultados.png?w=300" alt="resultados" width="300" height="246"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nos ayudaremos con las herramientas que tiene Firefox para poder identificar los elementos HTML de la página objetivo:&lt;br&gt;
&lt;a href="http://pythonpiura.org/2016/01/herramientas.png" rel="attachment wp-att-86"&gt;&lt;img class="alignnone size-medium wp-image-86" src="https://pythonpiura.files.wordpress.com/2016/01/herramientas.png?w=300" alt="Herramientas" width="300" height="88"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Empezamos identificando la caja de texto donde se envían los datos a consultar:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/01/caja.png" rel="attachment wp-att-87"&gt;&lt;img class="alignnone size-medium wp-image-87" src="https://pythonpiura.files.wordpress.com/2016/01/caja.png?w=300" alt="caja" width="300" height="36"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Y el botón que ejecuta la consulta:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonpiura.org/2016/01/boton.png" rel="attachment wp-att-88"&gt;&lt;img class="alignnone size-medium wp-image-88" src="https://pythonpiura.files.wordpress.com/2016/01/boton.png?w=300" alt="boton" width="300" height="23"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ahora que ya tenemos identificados estos elementos procedemos a escribir nuestro script en python:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;/p&gt;
&lt;p&gt;# -*- coding: utf-8 -*-&lt;br&gt;
from selenium import webdriver&lt;br&gt;
from selenium.webdriver.common.by import By&lt;br&gt;
from selenium.webdriver.support.wait import WebDriverWait&lt;br&gt;
from selenium.webdriver.support import expected_conditions as EC&lt;br&gt;
import os&lt;/p&gt;
&lt;p&gt;def ir_paginas_blancas_web(cadena):&lt;br&gt;
    driver = webdriver.Firefox()&lt;br&gt;
    #Página a la que queremos acceder&lt;br&gt;
    driver.get("http://www.paginasblancas.pe")&lt;br&gt;
    lista_datos = []&lt;br&gt;
    try:&lt;br&gt;
        #Verificamos si el elemento con ID="nName" ya está cargado, este elemento es la caja de texto donde se hacen las busquedas&lt;br&gt;
        WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.ID, "nName")))&lt;br&gt;
        #Obtenemos la caja de texto de busquedas&lt;br&gt;
        input_nombre = driver.find_element_by_id("nName")&lt;br&gt;
        #Enviamos la cadena que estamos buscando&lt;br&gt;
        input_nombre.send_keys(cadena)&lt;br&gt;
        #Obtenemos el botón que ejecuta la búsqueda&lt;br&gt;
        boton = driver.find_element_by_id("btnSrchName")&lt;br&gt;
        #Damos click al botón&lt;br&gt;
        boton.click()&lt;br&gt;
    except:&lt;br&gt;
        #Mostramos este mensaje en caso de que se presente algún problema&lt;br&gt;
        print "El elemento no está presente"&lt;br&gt;
    try:&lt;br&gt;
        #Si se encuentran resultados la página los muestra en elementos de nombre "m-results-business"&lt;br&gt;
        #Para ello esperamos que estos elementos se carguen para proceder a consultarlos&lt;br&gt;
        WebDriverWait(driver, 5).until(EC.presence_of_all_elements_located((By.CLASS_NAME, "m-results-business")))&lt;br&gt;
    except:&lt;br&gt;
        print ‘Elementos no encontrados’&lt;br&gt;
    #Obtenemos en una lista los elementos encontrados&lt;br&gt;
    resultados = driver.find_elements_by_class_name("m-results-business")&lt;br&gt;
    for resultado in resultados:&lt;br&gt;
        #En cada uno de los elementos encontrados buscamos un elemento interno que tiene por nombre info&lt;br&gt;
        datos = resultado.find_element_by_class_name("info")&lt;br&gt;
        #Dentro del elemento interno encontrado buscamos aquellos elementos que son enlaces(etiqueta &amp;lt;a&amp;gt;)&lt;br&gt;
        nombre = datos.find_element_by_tag_name(‘a’)&lt;br&gt;
        #Comprobamos si la cadena que buscamos coincide con la razón social o el nombre mostrado por la página&lt;br&gt;
        if nombre.text.upper().find(cadena)&amp;lt;&amp;gt;-1 or cadena.find(nombre.text.upper())&amp;lt;&amp;gt;-1:&lt;br&gt;
            #Obtenemos la parte de la dirección&lt;br&gt;
            span = datos.find_elements_by_tag_name(‘span’)&lt;br&gt;
            direccion = span[2].text&lt;br&gt;
            partes_ubigeo = span[3].text.split(‘-’)&lt;br&gt;
            distrito = partes_ubigeo[0].strip()&lt;br&gt;
            try:&lt;br&gt;
                departamento = partes_ubigeo[1].strip()&lt;br&gt;
            except:&lt;br&gt;
                departamento = ‘-’&lt;br&gt;
        #Obtenemos los Datos telefonicos para ello debemos simular el click en el botón que dice "Ver Teléfono"&lt;br&gt;
        boton_telefono = resultado.find_element_by_class_name("m-button–results-business–icon")&lt;br&gt;
        boton_telefono.click()&lt;br&gt;
        #Obtenemos los teléfonos que se muestran como enlaces&lt;br&gt;
        enlaces = resultado.find_elements_by_tag_name(‘a’)&lt;br&gt;
        telefono = enlaces[1].text.replace(‘ ‘, ”)&lt;br&gt;
        #Finalmente metemos en una lista de listas los datos obtenidos&lt;br&gt;
        lista_datos.append([direccion,distrito,departamento,telefono])&lt;/p&gt;
&lt;p&gt;    driver.close()&lt;br&gt;
    return lista_datos&lt;/p&gt;
&lt;p&gt;def main():&lt;br&gt;
    print ir_paginas_blancas_web(‘UNIVERSIDAD DE LIMA’)&lt;/p&gt;
&lt;p&gt;main()&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
</description><category>Python</category><category>Selenium</category><guid>http://pythonpiura.org/posts/2016/01/25/web-scraping-con-selenium/</guid><pubDate>Tue, 26 Jan 2016 03:51:19 GMT</pubDate></item><item><title>Django y Microsoft SQL Server</title><link>http://pythonpiura.org/posts/2016/01/25/django-y-microsoft-sql-server/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p style="text-align:justify;"&gt;Si por algún oscuro motivo necesitas conectar Django con Microsoft SQL Server, la solución la tiene el proyecto django-pyodbc-azure la información completa sobre el proyecto la encontrarán en su web oficial:&lt;br&gt;
https://github.com/michiya/django-pyodbc-azure&lt;br&gt;
La última versión del proyecto soporta Django 1.9.1 y Microsoft SQL Server 2005,2008/2008R2,2012,2014.&lt;br&gt;
Para empezar a trabajar debemos instalar de la siguiente forma:&lt;br&gt;
pip install django-pyodbc-azure&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Y luego configurar el archivo settings de nuestro proyecto, en la parte relacionada a la conexión a las bases de datos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
DATABASES = {&lt;br&gt;
    ‘default’: {&lt;br&gt;
        ‘ENGINE’: ‘sql_server.pyodbc’,&lt;br&gt;
        ‘NAME’: ‘NOMBRE_BD’,&lt;br&gt;
        ‘USER’: ‘usuario’,&lt;br&gt;
        ‘PASSWORD’: ‘password’,&lt;br&gt;
        ‘HOST’: ‘IP_SERVIDOR_SQL_SERVER’,&lt;br&gt;
        ‘PORT’: ”,&lt;br&gt;
        ‘OPTIONS’: {&lt;br&gt;
            ‘driver’: ‘SQL Server Native Client 10.0′,&lt;br&gt;
            }&lt;br&gt;
    },&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Y listo eso es todo, si desean conocer un poco mas este excelente proyecto remitanse a su página web.&lt;br&gt;
Saludos.&lt;/p&gt;
</description><category>Django</category><category>Python</category><guid>http://pythonpiura.org/posts/2016/01/25/django-y-microsoft-sql-server/</guid><pubDate>Mon, 25 Jan 2016 20:38:02 GMT</pubDate></item><item><title>Obtener Módulos de un Proyecto y Vistas de una Aplicación en Django</title><link>http://pythonpiura.org/posts/2016/01/19/obtener-modulos-de-un-proyecto-y-vistas-de-una-aplicacion-en-django/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p&gt;Debido a un requerimiento en un proyecto necesitabamos tener una página donde administrar todas las aplicaciones que hemos creado en nuestro proyecto Django y poder revisar que vistas(views) tiene cada uno de estas aplicaciones, para ello creamos una aplicación llamada permisos y una vista llamada AplicacionesProyecto de la siguiente manera:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
class AplicacionesProyecto(View):&lt;/p&gt;
&lt;p&gt;def get(self, request, *args, **kwargs):&lt;br&gt;
    aplicaciones = [ app for app in miproyecto.settings.INSTALLED_APPS if not "django" in app ]&lt;br&gt;
    context={‘aplicaciones’:aplicaciones}&lt;br&gt;
    return render(request, ‘reporte_aplicaciones.html’,context)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Nuestro template se llama reporte_aplicaciones.html y tiene la siguiente estructura:&lt;/p&gt;
&lt;p&gt;[sourcecode language="html"]&lt;br&gt;
{% extends "base_permisos.html" %}&lt;br&gt;
{% block titulo_opcion %}&lt;br&gt;
    Reporte de Aplicaciones&lt;br&gt;
{% endblock titulo_opcion %}&lt;br&gt;
{% block cuerpo_opcion %}&lt;br&gt;
&amp;lt;table class="table table-striped"&amp;gt;&lt;br&gt;
	&amp;lt;tbhead&amp;gt;&lt;br&gt;
		&amp;lt;tr&amp;gt;&lt;br&gt;
		&amp;lt;th&amp;gt;Nombre&amp;lt;/th&amp;gt;&lt;br&gt;
		&amp;lt;th&amp;gt;Vistas&amp;lt;/th&amp;gt;&lt;br&gt;
		&amp;lt;/tr&amp;gt;&lt;br&gt;
	&amp;lt;/tbhead&amp;gt;&lt;br&gt;
	&amp;lt;tbody&amp;gt;&lt;br&gt;
		{% for app in aplicaciones %}&lt;br&gt;
		&amp;lt;tr&amp;gt;&lt;br&gt;
			&amp;lt;td&amp;gt;{{ app }}&amp;lt;/td&amp;gt;&lt;br&gt;
			&amp;lt;td&amp;gt;&lt;br&gt;
				&amp;lt;a class="btn btn-small" href="{% url ‘permisos:reporte_vistas’ app %}"&amp;gt;&lt;br&gt;
					&amp;lt;span class="glyphicon glyphicon-folder-open"&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;
				&amp;lt;/a&amp;gt;&lt;br&gt;
			&amp;lt;/td&amp;gt;&lt;br&gt;
		&amp;lt;/tr&amp;gt;&lt;br&gt;
		{% endfor %}&lt;br&gt;
	&amp;lt;/tbody&amp;gt;&lt;br&gt;
&amp;lt;/table&amp;gt;&lt;br&gt;
{% endblock cuerpo_opcion %}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;La idea es obtener un listado de tal manera que al dar click en el enlace de cada uno de los módulos podamos ver las vistas(Views) que tiene cada una de las aplicaciones:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
class ReporteVistas(View):&lt;/p&gt;
&lt;p&gt;	def get(self, request, *args, **kwargs):&lt;br&gt;
		aplicacion = self.kwargs['aplicacion']&lt;br&gt;
		lista_clases = []&lt;br&gt;
		for nombre_modulo,instancia_modulo in inspect.getmembers(sys.modules[aplicacion]):&lt;br&gt;
			if nombre_modulo==’views’:&lt;br&gt;
				codigo_fuente = inspect.getsource(instancia_modulo)&lt;br&gt;
				codigo_fuente = codigo_fuente.replace(" ", "")&lt;br&gt;
				for miembro in dir(instancia_modulo):&lt;br&gt;
					obj = getattr(instancia_modulo, miembro)&lt;br&gt;
					if inspect.isclass(obj):&lt;br&gt;
						cadena_clase = ‘class’ + miembro&lt;br&gt;
						if codigo_fuente.find(cadena_clase)&amp;gt;=0:&lt;br&gt;
							lista_clases.append(miembro)&lt;br&gt;
		context={‘vistas’:lista_clases}&lt;br&gt;
		return render(request, ‘reporte_vistas_aplicacion.html’,context)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Nuestro template es reporte_vistas_aplicacion.html y tiene el siguiente contenido:&lt;/p&gt;
&lt;p&gt;[sourcecode language="html"]&lt;br&gt;
{% extends "base_permisos.html" %}&lt;br&gt;
{% block titulo_opcion %}&lt;br&gt;
	Reporte de Vistas&lt;br&gt;
{% endblock titulo_opcion %}&lt;br&gt;
{% block cuerpo_opcion %}&lt;br&gt;
	{% for vista in vistas %}&lt;br&gt;
		{{ vista }}&lt;br&gt;
	{% endfor %}&lt;br&gt;
{% endblock cuerpo_opcion %}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Los urls respectivos son de la siguiente manera, archivo urls.py:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
url(r’^aplicaciones_proyecto’, login_required(AplicacionesProyecto.as_view()), name="aplicaciones_proyecto"),&lt;br&gt;
url(r’^reporte_vistas/(?P&amp;lt;aplicacion&amp;gt;.+)/$’, login_required(ReporteVistas.as_view()), name="reporte_vistas"),&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Así de esta manera tenemos un procedimiento un tanto rudimentario pero útil con el que obtenemos, las aplicaciones de nuestro proyecto y las vistas de cada una de ellas.&lt;br&gt;
Hasta la próxima.&lt;/p&gt;
</description><category>Django</category><category>Python</category><guid>http://pythonpiura.org/posts/2016/01/19/obtener-modulos-de-un-proyecto-y-vistas-de-una-aplicacion-en-django/</guid><pubDate>Wed, 20 Jan 2016 03:53:56 GMT</pubDate></item><item><title>Selenium con Python</title><link>http://pythonpiura.org/posts/2014/09/18/selenium-con-python/</link><dc:creator>Miguel Amaya</dc:creator><description>&lt;p style="text-align:justify;"&gt;Buenas noches estimados amigos en esta oportunidad vamos a trabajar con Selenium, esta excelente herramienta que nos permite testear nuestras aplicaciones web actuando como si lo hiciera un usuario final que interactúa con nuestra aplicación, la primera vez que la probé me sorprendí gratamente porque no sabía de la existencia de una herramienta tan interesante, bueno manos a la obra, para instalar selenium con Python debemos usar nuestra querida herramienta pip de la siguiente manera:&lt;/p&gt;
&lt;p&gt;[sourcecode language="bash"]&lt;br&gt;
    sudo pip install selenium&lt;br&gt;
[/sourcecode]&lt;br&gt;
Si tuviésemos configurado un entorno virtual simplemente trabajaríamos así:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
    pip install selenium&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Con esto ya tendremos instalada esta excelente aplicación, si por algún motivo tuviesen algún error o ya tuviesen instalado selenium y quieren actualizarlo deben poner lo siguiente en su terminal:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
    pip install selenium –upgrade&lt;br&gt;
[/sourcecode]&lt;br&gt;
Para probar su funcionamiento debemos tipear este ejemplo bastante simple:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
    #Importamos el módulo webdriver que nos permite interactuar con nuestro navegador&lt;br&gt;
    from selenium import webdriver&lt;br&gt;
    #Importamos la clase Keys que provee las teclas RETURN, F1, ALT, etc de nuestro teclado&lt;br&gt;
    from selenium.webdriver.common.keys import Keys&lt;br&gt;
    #Creamos una instancia de Firefox webdriver para poder usar el navegador firefox en esta prueba&lt;br&gt;
    driver = webdriver.Firefox()&lt;br&gt;
    #El método get permite navegar hacia un enlace determinado en este caso la página de Python.org&lt;br&gt;
    #WebDriver esperará hasta que la página esté cargada&lt;br&gt;
    driver.get("http://www.python.org")&lt;br&gt;
    #En esta línea confirmaremos si el título tiene la palabra Python&lt;br&gt;
    assert "Python" in driver.title&lt;br&gt;
    #WebDriver ofrece varias maneras de encontrar los elementos de una página web&lt;br&gt;
    #En este ejemplo queremos encontrar el elemento que tenga como atributo name la letra "q"(es la barra de busqueda de la página)&lt;br&gt;
    elem = driver.find_element_by_name("q")&lt;br&gt;
    #Como ya localizamos el elemento y sabemos que es una caja de texto, vamos a escribir en ella la palabra "selenium"&lt;br&gt;
    elem.send_keys("selenium")&lt;br&gt;
    #Y finalmente enviaremos la busqueda pulsando la tecla RETURN&lt;br&gt;
    elem.send_keys(Keys.RETURN)&lt;br&gt;
    #Cerramos el navegador&lt;br&gt;
    driver.close()&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Verán que cuando ejecuten el script demorará un poquito pero nos mostrará una ventana de Firefox, posteriormente cargará la página de Python.org y en la caja de busqueda escribirá la palabra “selenium” para finalmente cerrar el navegador que había abierto culminando la ejecución del script.&lt;/p&gt;
&lt;p style="text-align:justify;"&gt;Esperemos que este pequeño post sea de gran utilidad para ustedes queridos lectores y si tuviesen algún problema al ejecutar el script por favor nos avisan.&lt;/p&gt;
&lt;p&gt;Saludos.&lt;/p&gt;
</description><category>Python</category><category>Selenium</category><guid>http://pythonpiura.org/posts/2014/09/18/selenium-con-python/</guid><pubDate>Thu, 18 Sep 2014 06:15:18 GMT</pubDate></item></channel></rss>